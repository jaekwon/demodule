// Generated by CoffeeScript 1.3.3
(function() {
  var assert, coffee, compact, findit, parser, uglify, _ref;

  require('sugar');

  assert = require('assert');

  findit = require('findit');

  _ref = require('uglify-js'), parser = _ref.parser, uglify = _ref.uglify;

  coffee = require('coffee-script');

  compact = function(array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (item) {
        _results.push(item);
      }
    }
    return _results;
  };

  module.exports = function(modules, callback, options) {
    var builtins, builtinsPath, code, compiled, compiler, compilers, derequired, dirpath, file, filename, filepath, fn, knownSuffixes, minCode, modulename, name, path, relpath, rootDir, source, suffix, suffixFilter, toCompile, _, _files, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _modules, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (options == null) {
      options = {};
    }
    compilers = (_ref1 = options.compilers) != null ? _ref1 : {};
    if ((_ref2 = compilers['js']) == null) {
      compilers['js'] = function(code) {
        return code;
      };
    }
    if ((_ref3 = compilers['coffee']) == null) {
      compilers['coffee'] = function(code) {
        return coffee.compile(code);
      };
    }
    rootDir = (_ref4 = options.rootDir) != null ? _ref4 : '';
    builtins = (_ref5 = options.builtins) != null ? _ref5 : true;
    if (builtins) {
      assert.ok(__filename.endsWith('demodule.js'));
      builtinsPath = "" + __filename.slice(0, __filename.length - 12) + "/builtins";
      _ref6 = findit.findSync(builtinsPath);
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        filepath = _ref6[_i];
        modules.push({
          name: filepath.split('/').last().slice(0, -3),
          path: filepath
        });
      }
    }
    toCompile = [];
    knownSuffixes = Object.keys(compilers);
    for (_j = 0, _len1 = modules.length; _j < _len1; _j++) {
      _ref7 = modules[_j], name = _ref7.name, path = _ref7.path;
      if (!path.startsWith('/')) {
        path = rootDir + path;
      }
      _ref9 = (_ref8 = path.match(/(.*?)\/\*\*\.([a-zA-Z0-9]+)$/)) != null ? _ref8 : [], _ = _ref9[0], dirpath = _ref9[1], suffixFilter = _ref9[2];
      if (dirpath) {
        _ref10 = findit.findSync(dirpath);
        for (_k = 0, _len2 = _ref10.length; _k < _len2; _k++) {
          filepath = _ref10[_k];
          _ref11 = filepath.match(/(.*?)(?:\.([a-zA-Z0-9]+))?$/), _ = _ref11[0], filename = _ref11[1], suffix = _ref11[2];
          if (!suffix) {
            continue;
          }
          if (suffixFilter && suffix !== suffixFilter) {
            continue;
          }
          relpath = filename.slice(dirpath.length);
          if (relpath.startsWith('/')) {
            relpath = relpath.slice(1);
          }
          if (relpath === 'index') {
            modulename = name || 'index';
          } else if (relpath.endsWith('/index')) {
            modulename = compact([name, relpath.slice(0, -6)]).join('/');
          } else {
            modulename = compact([name, relpath]).join('/');
          }
          compiler = compilers[suffix];
          if (!compiler) {
            console.log("DEmodule ignored file with no compiler: " + filepath);
            continue;
          }
          toCompile.push({
            file: filepath,
            fn: compiler,
            name: modulename
          });
        }
      } else {
        filepath = path;
        _ref12 = filepath.match(/(.*?)(?:\.([a-zA-Z0-9]+))?$/), _ = _ref12[0], filename = _ref12[1], suffix = _ref12[2];
        compiler = compilers[suffix];
        if (!compiler) {
          throw new Error("Dunno how to compile '" + filepath + "' with " + suffix + " suffix");
        }
        toCompile.push({
          file: filepath,
          fn: compiler,
          name: name
        });
      }
    }
    _files = {};
    _modules = {};
    for (_l = 0, _len3 = toCompile.length; _l < _len3; _l++) {
      _ref13 = toCompile[_l], file = _ref13.file, name = _ref13.name;
      if (_files[file]) {
        console.log("WARN: Duplicate file " + file);
      }
      if (_modules[name]) {
        throw new Error("Duplicate module " + name);
      }
      _files[file] = _modules[name] = true;
    }
    derequired = '';
    for (_m = 0, _len4 = toCompile.length; _m < _len4; _m++) {
      _ref14 = toCompile[_m], file = _ref14.file, name = _ref14.name, fn = _ref14.fn;
      source = require('fs').readFileSync(file, 'utf8');
      compiled = fn(source);
      derequired += "require['" + name + "'] = function() {\n    return new function() {\n        var exports = require['" + name + "'] = this;\n        var module = {exports:exports};\n        var process = require(\"__browserify_process\");\n        var __filename = \"" + file + "\";\n        " + compiled + "\n        return (require['" + name + "'] = module.exports);\n    };\n};\nrequire['" + name + "'].nonce = nonce;\n\n";
    }
    code = "(function(root) {\n    return (function() {\n        var nonce = {nonce:'nonce'};\n        function require(path){\n          var module = require[path];\n          if (!module) {\n            throw new Error(\"Can't find module \"+path);\n          }\n          if (module.nonce === nonce) {\n            module = module();\n            return module;\n          } else {\n            return module;\n          }\n        }\n        " + derequired + "\n        " + callback + "\n    })();\n})(this);";
    minCode = uglify.gen_code(uglify.ast_squeeze(uglify.ast_mangle(parser.parse(code))), {
      ascii_only: true
    });
    return {
      code: code,
      minCode: minCode
    };
  };

}).call(this);
