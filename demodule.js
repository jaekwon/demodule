// Generated by CoffeeScript 1.3.3
(function() {
  var assert, coffee, compact, endsWith, findit, fs, last, parser, startsWith, uglify, _ref;

  assert = require('assert');

  findit = require('findit');

  _ref = require('uglify-js'), parser = _ref.parser, uglify = _ref.uglify;

  coffee = require('coffee-script');

  fs = require('fs');

  compact = function(array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (item) {
        _results.push(item);
      }
    }
    return _results;
  };

  startsWith = function(string, literal, start) {
    return literal === string.substr(start, literal.length);
  };

  endsWith = function(string, literal, back) {
    var len;
    len = literal.length;
    return literal === string.substr(string.length - len - (back || 0), len);
  };

  last = function(array, back) {
    return array[array.length - (back || 0) - 1];
  };

  module.exports = function(modules, callback, options) {
    var builtins, builtinsPath, code, compiled, compiler, compilers, derequired, dirpath, file, filename, filepath, filepaths, fn, knownSuffixes, minCode, minimize, modulename, name, path, recursive, relpath, rootDir, source, suffix, suffixFilter, toCompile, _, _files, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _modules, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (options == null) {
      options = {};
    }
    compilers = (_ref1 = options.compilers) != null ? _ref1 : {};
    if ((_ref2 = compilers['js']) == null) {
      compilers['js'] = function(code) {
        return code;
      };
    }
    if ((_ref3 = compilers['coffee']) == null) {
      compilers['coffee'] = function(code) {
        return coffee.compile(code);
      };
    }
    rootDir = (_ref4 = options.rootDir) != null ? _ref4 : '';
    builtins = (_ref5 = options.builtins) != null ? _ref5 : true;
    minimize = (_ref6 = options.minimize) != null ? _ref6 : true;
    if (builtins) {
      assert.ok(endsWith(__filename, 'demodule.js'));
      builtinsPath = "" + __filename.slice(0, __filename.length - 12) + "/builtins";
      _ref7 = findit.findSync(builtinsPath);
      for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
        filepath = _ref7[_i];
        modules.push({
          name: last(filepath.split('/')).slice(0, -3),
          path: filepath
        });
      }
    }
    toCompile = [];
    knownSuffixes = Object.keys(compilers);
    for (_j = 0, _len1 = modules.length; _j < _len1; _j++) {
      _ref8 = modules[_j], name = _ref8.name, path = _ref8.path;
      if (!startsWith(path, '/')) {
        path = rootDir + path;
      }
      _ref10 = (_ref9 = path.match(/(.*?)\/\*(\*?)\.([a-zA-Z0-9]+)$/)) != null ? _ref9 : [], _ = _ref10[0], dirpath = _ref10[1], recursive = _ref10[2], suffixFilter = _ref10[3];
      if (dirpath) {
        dirpath = fs.realpathSync(dirpath);
        if (recursive) {
          filepaths = findit.findSync(dirpath);
        } else {
          filepaths = fs.readdirSync(dirpath).map(function(path) {
            return "" + dirpath + "/" + path;
          });
        }
        for (_k = 0, _len2 = filepaths.length; _k < _len2; _k++) {
          filepath = filepaths[_k];
          _ref11 = filepath.match(/(.*?)(?:\.([a-zA-Z0-9]+))?$/), _ = _ref11[0], filename = _ref11[1], suffix = _ref11[2];
          if (!suffix) {
            continue;
          }
          if (suffixFilter && suffix !== suffixFilter) {
            continue;
          }
          if (filename.slice(0, dirpath.length) !== dirpath) {
            throw new Error("Demodule doesn't know how to deal with inner symlinks (yet)");
          }
          relpath = filename.slice(dirpath.length);
          if (startsWith(relpath, '/')) {
            relpath = relpath.slice(1);
          }
          if (relpath === 'index') {
            modulename = name || 'index';
          } else if (endsWith(relpath, '/index')) {
            modulename = compact([name, relpath.slice(0, -6)]).join('/');
          } else {
            modulename = compact([name, relpath]).join('/');
          }
          console.log("Demodule packing " + modulename + " -> " + filename);
          compiler = compilers[suffix];
          if (!compiler) {
            console.log("Demodule ignored file with no compiler: " + filepath);
            continue;
          }
          toCompile.push({
            file: filepath,
            fn: compiler,
            name: modulename
          });
        }
      } else {
        filepath = path;
        _ref12 = filepath.match(/(.*?)(?:\.([a-zA-Z0-9]+))?$/), _ = _ref12[0], filename = _ref12[1], suffix = _ref12[2];
        compiler = compilers[suffix];
        if (!compiler) {
          throw new Error("Dunno how to compile '" + filepath + "' with " + suffix + " suffix");
        }
        console.log("Demodule packing " + name + " -> " + filepath);
        toCompile.push({
          file: filepath,
          fn: compiler,
          name: name
        });
      }
    }
    _files = {};
    _modules = {};
    for (_l = 0, _len3 = toCompile.length; _l < _len3; _l++) {
      _ref13 = toCompile[_l], file = _ref13.file, name = _ref13.name;
      if (_files[file]) {
        console.log("WARN: Duplicate file " + file);
      }
      if (_modules[name]) {
        throw new Error("Duplicate module " + name);
      }
      _files[file] = _modules[name] = true;
    }
    console.log("Demodule packed " + toCompile.length + " files!");
    derequired = '';
    for (_m = 0, _len4 = toCompile.length; _m < _len4; _m++) {
      _ref14 = toCompile[_m], file = _ref14.file, name = _ref14.name, fn = _ref14.fn;
      source = require('fs').readFileSync(file, 'utf8');
      compiled = fn(source);
      derequired += "require['" + name + "'] = function() {\n    return new function() {\n        var exports = require['" + name + "'] = this;\n        var module = {exports:exports};\n        var process = require(\"__browserify_process\");\n        var __filename = \"" + file + "\";\n        " + compiled + "\n        return (require['" + name + "'] = module.exports);\n    };\n};\nrequire['" + name + "'].nonce = nonce;\n\n";
    }
    code = "(function(root) {\n    return (function() {\n\n        var nonce = {nonce:'nonce'};\n        var currentAbsModulePath = '';\n\n        function require( path ) {\n          // resolve relative path\n          if (path.substr(0,2) === './') {\n            path = currentAbsModulePath + path.substr(1);\n          }\n          //\n          var module = require[path];\n          if (!module) {\n            throw new Error(\"Can't find module \"+path);\n          }\n          // if we haven't run the module yet\n          if (module.nonce === nonce) {\n            var oldAbsModulePath = currentAbsModulePath;\n            currentAbsModulePath = pathDir(path);\n            module = module();\n            currentAbsModulePath = oldAbsModulePath;\n            return module;\n          } else {\n            return module;\n          }\n        }\n\n        function pathDir( path ) {\n          var lastSlash = path.lastIndexOf(\"/\");\n          if (lastSlash === -1) {\n            return path;\n          } else {\n            return path.substring(0,lastSlash);\n          }\n        }\n\n        " + derequired + "\n        " + callback + "\n    })();\n})(this);";
    if (minimize) {
      minCode = uglify.gen_code(uglify.ast_squeeze(uglify.ast_mangle(parser.parse(code))), {
        ascii_only: true
      });
    }
    return {
      code: code,
      minCode: minCode
    };
  };

}).call(this);
